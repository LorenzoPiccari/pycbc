#!/usr/bin/env python

# Copyright (C) 2016 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Workflow generator for a stochastic template bank construction with pycbc_brute_bank.
"""

#imports
import os
import argparse
import logging
import pycbc
import pycbc.version
import pycbc.workflow as wf
from pycbc.workflow.pegasus_workflow import SubWorkflow

# Boiler-plate stuff
__author__  = "Lorenzo Piccari <lorenzo.@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__    = pycbc.version.date
__program__ = "pycbc_make_brute_bank_workflow"

##################################
# DEFINE CLASSES AND FUNCTIONS   #
##################################

class BruteBankExecutable(wf.Executable):
    """ Class for running pycbc_brute_bank.
    """
    # This outputs a dax file.
    current_retention_level = wf.Executable.FINAL_RESULT
   
    # This tells us that --input-file is a file option NOT SURE WHAT THIS IS 
    file_input_options = wf.Executable.file_input_options + ['--input-file']

    def create_node(self):
        node = wf.Executable.create_node(self)

        return node


def BruteBankExe(workflow, minimal_match, input_bank, out_dir, tag=None):

    "Generate a job of pycbc_brute_bank"

    tags = []
    if tag is not None:
        tags.append(tag)

 # Creating the node
    exe = BruteBankExecutable\
          (workflow.cp, 'brute_bank', out_dir=out_dir,
          ifos=workflow.ifos, tags=tags)

    node = exe.create_node()
    
 # Adding necessary options
    node.add_opt('--minimal-match', minimal_match)
 
    if input_bank is not None:
        node.add_input_opt('--input-file', input_bank)

    node.new_output_file_opt(workflow.analysis_time, '.hdf', '--output-file', tags=tags)

    workflow += node

    return node.output_file


##############################################################################
# Argument parsing and setup of workflow                                     #
##############################################################################


# Use the standard workflow command-line parsing routines. Things like a
# configuration file are specified within the "workflow command line group"
# so run this with --help to see what options are added.
_desc = __doc__[1:]
parser = argparse.ArgumentParser(description=_desc)
parser.add_argument('--version', action='version', version=__version__)
parser.add_argument("--output-file", type=str, default=None,
                    help="Specify the output file name. Either a name can be "
                         "provided or a full path to file. Is this is not "
                         "given a filename and location is chosen ")


wf.add_workflow_command_line_group(parser)
wf.add_workflow_settings_cli(parser, include_subdax_opts=True)
args = parser.parse_args()

# Create the workflow object
workflow = wf.Workflow(args)

wf.makedir(args.output_dir)
os.chdir(args.output_dir)
args.output_dir = '.'

##############################################################################
#   Workflow                                                                 #
##############################################################################

logging.info("Setting up the pycbc_brute_bank jobs.")

#Defining the list of minimal matches to use for the construction of the coarse banks and the final one

minimal_match = workflow.cp.get('workflow', 'minimal-match')

min_matches = workflow.cp.get('workflow', 'coarse-min-matches')
min_matches = min_matches.split(' ')
if len(min_matches) == 0:
    raise ValueError("No minimal match values for the coarse banks are actually provided!")

min_matches.sort()
if min_matches[-1] > minimal_match:
    raise ValueError("The values of the minimal match used for the coarse banks cannot be higher than minimal-match")

min_matches.append(minimal_match)

#Checking if an inital seed bank is provided
seed_file=None
if workflow.cp.has_option('workflow', 'seed-bank'):
    # If a seed bank is provided register it as a File object
    seed_bank = workflow.cp.get('workflow', 'seed-bank')
    #seed_file = wf.File.from_path(seed_bank, store_file=args.output_dir)
    seed_file = wf.resolve_url_to_file(seed_bank)

#Setting up the jobs
seed_tag = 'INI'
output_banks = {}
output_banks[seed_tag] = seed_file

for mm in min_matches:
    bank_tag = 'BANK_MIN_MATCH'+'_'+str(mm)
    bank = BruteBankExe(workflow, mm, output_banks[seed_tag], args.output_dir, tag=bank_tag) 
    seed_tag=bank_tag
    output_banks[bank_tag]=bank

workflow.save()
